<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Lecture 4</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="lecture-4">Lecture 4</h1>
<h1 id="templates">Templates</h1>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mysum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span></span>{
    <span class="hljs-keyword">return</span> a+b
}
<span class="hljs-string">&#x27;&#x27;&#x27;</span>
<span class="hljs-string">&#x27;&#x27;&#x27;</span>
<span class="hljs-type">int</span> <span class="hljs-built_in">mysum</span>(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b){
    <span class="hljs-keyword">return</span> a+b
}
<span class="hljs-string">&#x27;&#x27;&#x27;</span>
<span class="hljs-type">int</span> <span class="hljs-built_in">mysum</span>(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; b){
    <span class="hljs-keyword">return</span> a+b
}
</code></pre>
<p>Does blocks of code perform the same operation (sum two numbers) with different type but it is still the same function.
In C++ we have templates and so we don't have to do that. We can replace all the previous blocks of code with the block above:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">mySum</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;a , <span class="hljs-type">const</span> T&amp;b)</span></span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>Instees typename we can write class. T is the name of the template.
We can write a generic function that can print all the types of variable:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;x)</span></span>{
    std::cout&lt;&lt;x&lt;&lt;std::endl;
}
</code></pre>
<p>We can also use a function with more than one templated variable as below  (we have to list the variable separated by a ','):</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">weird_function</span><span class="hljs-params">(T1&amp; a, T2&amp; b)</span></span>{
    a = a+<span class="hljs-number">1</span>;
    b = b+<span class="hljs-number">1</span>;
}
</code></pre>
<p>To call a function with a templated variable we have to write the following code:</p>
<pre><code class="language-cpp">...
<span class="hljs-type">int</span> a{<span class="hljs-number">5</span>};
<span class="hljs-built_in">print</span>(a);
...
</code></pre>
<p>and the compiler understand that we want to use the type 'int'. The compiler so will create a function for the variable type.
If I want to be sure I can instanciate manually the type that I want for my function</p>
<pre><code class="language-cpp">...
<span class="hljs-built_in">print</span>&lt;<span class="hljs-type">int</span>&gt;(a)
...
</code></pre>
<p>If I have a function with two parameter templated is better to specify the types:</p>
<pre><code class="language-cpp">...
<span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">mySum</span>&lt;<span class="hljs-type">double</span>&gt;(a,b);
...
</code></pre>
<p>Problem when I do program structure (use header file and program file). I can write a file named &quot;function.hpp&quot; where I define all my functions:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;x)</span></span>{
    std::cout&lt;&lt;x&lt;&lt;std::endl;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">mySum</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;a , <span class="hljs-type">const</span> T&amp;b)</span></span>{
    <span class="hljs-keyword">return</span> a + b;
</code></pre>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;function.hpp&quot;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> a{<span class="hljs-number">8</span>};
    <span class="hljs-type">double</span> b{<span class="hljs-number">9.7</span>};
    <span class="hljs-built_in">print</span>&lt;<span class="hljs-type">int</span>&gt;(b)
}
</code></pre>
<p>If I try to compile the file main.cpp (with the make file) the compile will complain because it tries to compile before the function (and he want to create some object) but it doesn't know the type of the templated variable.
So we have to declare whitch type we will use in the program:</p>
<pre><code class="language-cpp">...
<span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> &amp;<span class="hljs-type">int</span>);
<span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp;)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span>
<span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-title">weird_function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">double</span>&amp;)</span>
...
</span></code></pre>
<p>Template every thing and put everything in .hpp file; that make more easier the things.</p>
<h2 id="class-templates">Class templates</h2>
<p>I can create a class and said that the type of the variable inside the class are of type T.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyClass</span>{
<span class="hljs-keyword">public</span>:
    T field1;
    T field2;
    <span class="hljs-built_in">CMyClass</span>(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b);
    <span class="hljs-comment">//A function inside the class that is templated with something else</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> M&gt;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_extra</span><span class="hljs-params">(<span class="hljs-type">const</span> M&amp; val)</span></span>;
}
</code></pre>
<p>To write the full definition of the function:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
CMyClass&lt;T&gt;::<span class="hljs-built_in">CMyClass</span> (<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b){
    field1 = a;
    field2 = b;
}
</code></pre>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> M&gt;
<span class="hljs-type">void</span> CMyClass&lt;T&gt;::<span class="hljs-built_in">print_extra</span> (<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b){
    std::cout&lt;&lt;field1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;field2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;val&lt;&lt;std::endl;
}
</code></pre>
<p>To create an istance of the class and to call a function inside the class I have to write the following code:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-function">CMyClass&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)</span></span>;
    var.<span class="hljs-built_in">print_extra</span>(<span class="hljs-number">9.1</span>);
}
</code></pre>
<p>We can template also numbers (only mathematical integer numbers that could be int, short int, long int, ...) as follow:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">short</span> <span class="hljs-type">int</span> N&gt;
<span class="hljs-type">void</span> <span class="hljs-title">add_number</span><span class="hljs-params">(T&amp; var)</span></span>{
    var = var + N;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">double</span> b{<span class="hljs-number">4.7</span>};
    <span class="hljs-built_in">add_number</span>&lt;<span class="hljs-type">double</span>,<span class="hljs-number">7</span>&gt;(b);
    std::cout&lt;&lt;b&lt;&lt;std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="variadic-template">Variadic template</h2>
<p>Used to work with many arguments. Example: print many parameters in a recursive way. I define a print funcion. We define the template Types with the variadic template (typename... Types) that can store a variable number of arguments of a variable type</p>
<pre><code class="language-cpp">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">const</span> &amp;T arg)</span></span>{
    <span class="hljs-comment">//when I have only one parameter of variable type this function was called</span>
    std::cout&lt;&lt;arg&lt;&lt;std::endl;
}

<span class="hljs-comment">//first value stored in T, others valued stored in Types (variadic variable) </span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; arg, <span class="hljs-type">const</span> Types&amp;... args)</span></span>{
    std::cout&lt;&lt;arg&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    <span class="hljs-built_in">myPring</span>(args...);
}
</code></pre>
<p>Following code to test the previuos functions:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">myPrint</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4.2</span>,<span class="hljs-string">&quot;ciao&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="specialize-template">Specialize template</h2>
<p>We want to do different things depending of the type of templated variable. I have to compare templated type with standard type with the following expression:</p>
<pre><code class="language-cpp"><span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;<span class="hljs-type">int</span>,T&gt;)
</code></pre>
<p>What is inside constexpr() is evaluated at compile time. We need to put that because templated function must be evaluated at compiled time. Notice that constexpr has been introduced in C++17 so is mandatory to add -std=c++17 to compile the code (not enabled by default).</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyClass</span>{
<span class="hljs-keyword">public</span>:    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span>;
    
};


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> CMyClass&lt;T&gt;::<span class="hljs-built_in">Function</span>()
{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_same_v&lt;<span class="hljs-type">int</span>,T&gt;)</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">&quot;we are dealing with int&quot;</span>&lt;&lt;std::endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_same_v&lt;<span class="hljs-type">double</span>,T&gt;)</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">&quot;we are dealing with double&quot;</span>&lt;&lt;std::endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_integral_v&lt;T&gt;)</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">&quot;something \&quot;integer\&quot; &quot;</span>&lt;&lt;std::endl;
    }<span class="hljs-keyword">else</span>{
        std::cout&lt;&lt;<span class="hljs-string">&quot;something non \&quot;integer\&quot; &quot;</span>&lt;&lt;std::endl;
    }
}
</code></pre>
<p>and afer a method to call create an instance of the class and test the method:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    CMyClass&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; var;
    var.<span class="hljs-built_in">Function</span>();
}
</code></pre>
<h1 id="vector">Vector</h1>
<p>In C++ is a built type of array:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
...
std::array&lt;<span class="hljs-type">int</span>,5&gt; arr;
...
</code></pre>
<p>We neet to specify the type.
Difference between array and vector: size in array could be change and mustn't to be known at compilation time.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
...
std::vector&lt;<span class="hljs-type">int</span>&gt;  vec;
...
</code></pre>
<p>std::vector does all memory menagement (very easy). If a programmer want to forget about memory management he can use vector.
Problem: push_bach() is a function thant add element at the end of the vector</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    
    std::array&lt;<span class="hljs-type">int</span>,5&gt; arr;<span class="hljs-comment">//need to specify the number of elements</span>
    std::vector&lt;<span class="hljs-type">int</span>&gt;  vec;
    vec.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);
    <span class="hljs-comment">//reserve memory</span>
    vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<span class="hljs-comment">//now you can do push_backs, but still better not</span>
    
    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">8</span>);<span class="hljs-comment">//avoid if you can in hpc!</span>
    
</code></pre>
<p>When push_back the vector try to have more memory at the end (vector is contiguous). At the inizialization the vector allocate a small piece of memory. If we continuously use the push_back function and at one point there is no enought space near. The vector ask to reallocate the in another space of memory and copy all the values previously initialize. Is it better to resize the array at the beginning with all the mwmory that I expect to use.</p>
<p>Is important to pass the reference in the functions that use vectors or an array:</p>
<pre><code class="language-cpp"><span class="hljs-comment">//Vector</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; v)</span></span>{
    <span class="hljs-comment">//printing with a &quot;normal&quot; loop</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++){
        std::cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
    <span class="hljs-comment">//&quot;ranged-based&quot; loop</span>
    <span class="hljs-comment">//can&#x27;t use this if we explicitly need an index</span>

    <span class="hljs-comment">//range based loop: for all element in vector (like in Python)</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; el:v){
        std::cout&lt;&lt;el&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;


<span class="hljs-comment">//Array</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_array</span><span class="hljs-params">(<span class="hljs-type">const</span> std::array&lt;T,N&gt;&amp; v)</span></span>{
    <span class="hljs-comment">//printing with a &quot;normal&quot; loop</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++){
        std::cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
    <span class="hljs-comment">//&quot;ranged-based&quot; loop</span>
    <span class="hljs-comment">//can&#x27;t use this if we explicitly need an index</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; el:v){
        std::cout&lt;&lt;el&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
}
}
</code></pre>
<p>An example of bad code (if the passed values isn't a vector the program will crash):</p>
<pre><code class="language-cpp"><span class="hljs-comment">//the next is a very &quot;unsafe&quot; function, we have to trust that the passed variable v is a vector</span>
<span class="hljs-comment">//actually has .size() and [] access operator</span>
<span class="hljs-comment">//it&#x27;s for you, as a programmer, to decide if you want this</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_whatever</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; v)</span></span>{
    <span class="hljs-comment">//printing with a &quot;normal&quot; loop</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++){
        std::cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
    <span class="hljs-comment">//&quot;ranged-based&quot; loop</span>
    <span class="hljs-comment">//can&#x27;t use this if we explicitly need an index</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; el:v){
        std::cout&lt;&lt;el&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
}
</code></pre>
<p>With array is it possible to work also in &quot;C style&quot;:</p>
<pre><code class="language-cpp"><span class="hljs-comment">//C-style function</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printC</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> size)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++){
        std::cout&lt;&lt;arr[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout&lt;&lt;std::endl;
}<span class="hljs-comment">//printC</span>
</code></pre>
<p>Some usefull methos for vectors:</p>
<pre><code class="language-cpp">vec.<span class="hljs-built_in">size</span>() <span class="hljs-comment">//numeber of initialized valued</span>
vec.<span class="hljs-built_in">capacity</span>() <span class="hljs-comment">//amount of reserved memory</span>
</code></pre>
<p>Matrix: don't create a vector-vector than each column/line will live in a different memory allocation (very bad for performance).</p>

        
        
    </body>
    </html>